GitHub Homework 2022-07-28 - Exercise 13 Scripting Exercises

Carl Tang Yong Han

Linux - Scripting Exercises:


For each activity, save your working script to a text file named as:
yourname-scripting-activity#.txt


// Activity 1:
Create a simple shell script to tell the user about their session – they need to know:

What their username is
What the current date is
What the time is
What their current working directory is
How many files they have in that directory
What is the biggest file in their current directory

Script CarlTangYongHan-scripting-activity1.txt
_____________________________________________
#!/bin/bash

echo This is about your session
echo User Name is `logname`
echo Current Date is `date +%d-%m-%Y`
echo The time is `date +%T`
echo Current working directory is `pwd`
echo Number of files in directory: `ls | wc -l`
echo Biggest file in current directory: `du -ah . | sort -n -r | head -1`
_____________________________________________
ubuntu@ip-172-31-17-240:~$ ./CarlTangYongHan-scripting-activity1.txt 
(Outcome:)
This is about your session
User Name is ubuntu
Current Date is 28-07-2022
The time is 07:46:01
Current working directory is /home/ubuntu
Number of files in directory: 47
Biggest file in current directory: 276K ./logs


// Activity 2:
Create a directory with a few test files in it (the files can be empty).
Now write a script that for every file in that directory you rename it to have an extension of today's date in YYYYMMDD format.

ubuntu@ip-172-31-17-240:~/scriptExerciseAct2$ ls
Test1  Test2  Test3

Script CarlTangYongHan-scripting-activity2.txt
______________________________
#!/bin/bash

path=~/scriptExerciseAct2

dateToday=`date +%Y%m%d`

cd $path

for  file in * 
do
newName="$file.$dateToday"
mv "$file" "$newName"
done

cd ~
_____________________________
Outcome:
ubuntu@ip-172-31-17-240:~$ ls ./scriptExerciseAct2/
Test1.20220729  Test2.20220729  Test3.20220729


// Activity 3:
You are in charge of creating a program for the lottery in your area! The options are for numbers between 1 and 50.
Create a script that picks 5 for each draw plus a bonus ball number between 1 and 10. Output the numbers to a file that has the date in its name.
Create another script that will allow users to check their lottery numbers and advise them if they match or not and how many matches they got.

Script CarlTangYongHan-scripting-activity3A.txt
____________________________________
#!/bin/bash


# Keep track of unchosen numbers
leftover=50

# Available numbers in the pool
poolArray=(`seq 1 50`)

# Keep track of unchosen numbers from 1 - 10
remainingOfTen=10

touch luckyDraw

function draw()
{
        # Check leftover pool size:
        leftover=${#poolArray[@]}

        if [ $leftover != 0 ]
        then
                # Randomly pick a number from leftover pool:
                R=$(($RANDOM%$leftover))

                selected=${poolArray[$R]}

                # Check if selected number falls within 1-10
                if [ $selected -ge 1 ] && [ $selected -le 10 ]
                then
                        (( remainingOfTen=remainingOfTen-1 ))
                fi

                # Remove picked number from pool:
                unset poolArray[$R]

                # Produce selected number:
                echo $selected
        fi
}

for i in {1..5}
do
# Add lucky number to record
draw >> luckyDraw
done

# Draw from 1 - 10 if applicable
if [ $remainingOfTen -ge 1 ]
then
R10=$(($RANDOM%$remainingOfTen))

selected10=${poolArray[$R10]}
unset poolArray[$R10]
(( remainingOfTen=remainingOfTen-1 ))
       
echo $selected10 >> luckyDraw
fi


mv luckyDraw luckyDraw`date +%Y%m%d`

___________________________________________


Script CarlTangYongHan-scripting-activity3A.txt
____________________________________
#!/bin/bash

filename="luckyDraw20220728"

echo This is for lottery check,
echo please enter your six numbers.

# count of lucky matches
match=0
# user inputs of 6 numbers kept in array
inputs=()
# actual winning numbers kept in array
actual=()

# Read data from lucky draw and load into array
while read num
do
	actual+=($num)
done < $filename

# Interact with user
for i in {1..6}
do
	actual+=($num)
	echo Your input $i please:
	read input
	inputs+=($input)
	if [ $input == ${actual[$((i-1))]} ]
	then
		echo Your input $i matches!
		match=$((match+1))
	else
		echo "Sorry, your input $i doesn't match"
		echo The actual lucky number is ${actual[$((i-1))]}.
	fi
	n=$((n+1))
done

if [ $match == 6 ]
then
	echo Congratulations, you match 100%!
else
	echo You matched $match out of 6 numbers.
fi

echo Actual lucky numbers: ${actual[@]}
echo Your number set is:-- ${inputs[@]}
______________________________________________

Example running of script:
ubuntu@ip-172-31-17-240:~$ cat luckyDraw20220728 
13
7
39
41
37
6
ubuntu@ip-172-31-17-240:~$ ./CarlTangYongHan-scripting-activity3B.txt
This is for lottery check,
please enter your six numbers.
Your input 1 please:
11
Sorry, your input 1 doesn't match
The actual lucky number is 13.
Your input 2 please:
7
Your input 2 matches!
Your input 3 please:
23
Sorry, your input 3 doesn't match
The actual lucky number is 39.
Your input 4 please:
34
Sorry, your input 4 doesn't match
The actual lucky number is 41.
Your input 5 please:
37
Your input 5 matches!
Your input 6 please:
45
Sorry, your input 6 doesn't match
The actual lucky number is 6.
You matched 2 out of 6 numbers.
Actual lucky numbers: 13 7 39 41 37 6
Your number set is:-- 11 7 23 34 37 45
_______________________________________


// Activity 4:
Write a script to validate how secure someone's password is. Things you would care about:
 - Length should be 8 or more characters
 - The password should contain numbers and letters
 - There should be both uppercase and lowercase letters

Script Activity4:
__________________________
#!/bin/bash

echo This is for testing password validity.
echo "Please enter a password (sorry, can't hide your password)."

read password

length=${#password}

# Check for number(s)
gotNum=$(echo $password | grep -E -c "[0-9]")

# Check for uppercase letter(s)
gotUpper=$(echo $password | grep -E -c "[A-Z]")

# Check for lowercase letter(s)
gotLower=$(echo $password | grep -E -c "[a-z]")

# Check for any letter(s)
gotLetter=$(if [ $gotUpper -ne 0 ] || [ $gotLower -ne 0 ]; then echo 1; else echo 0; fi)

# Responses to user

if [ $length -ge 8 ]
then
        echo Yup, your password is at least 8 characters.
else
        echo Oops, your password has less than 8 characters.
fi

if [ $gotNum -gt 0 ]
then
        echo Yup, your password contains number.
else
        echo Oops, your password does NOT contain number.
fi

if [ $gotLetter == 1 ]
then
        echo Yup, your password contains letter.

        if [ $gotUpper -gt 0 ]
        then
                echo Yup, your password contains uppercase letter.
        else
                echo Oops, your password does NOT have uppercase number.
        fi

        if [ $gotLower -gt 0 ]
        then
                echo Yup, your password contains lowercase letter.
        else
                echo Oops, your password does NOT have lowercase letter.
        fi
else
        echo Oops, your password does NOT contain any letter.
fi

# Give summative feedback

if  [ $length -ge 8 ] && [ $gotNum -gt 0 ] && \
        [ $gotUpper -gt 0 ] && [ $gotLower -gt 0 ]
then
        echo Your password meets requirements.
else
        echo Sorry, your password does NOT meet requirements.
fi
__________________________
Test running the script:
______________________
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity4
This is for testing password validity.
Please enter a password (sorry, can't hide your password).
[input:] blaBla7
Oops, your password has less than 8 characters.
Yup, your password contains number.
Yup, your password contains letter.
Yup, your password contains uppercase letter.
Yup, your password contains lowercase letter.
Sorry, your password does NOT meet requirements.

Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity4
This is for testing password validity.
Please enter a password (sorry, can't hide your password).
[input:] 123456789
Yup, your password is at least 8 characters.
Yup, your password contains number.
Oops, your password does NOT contain any letter.
Sorry, your password does NOT meet requirements.

Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity4
This is for testing password validity.
Please enter a password (sorry, can't hide your password).
[input:] BBB%$#1234
Yup, your password is at least 8 characters.
Yup, your password contains number.
Yup, your password contains letter.
Yup, your password contains uppercase letter.
Oops, your password does NOT have lowercase letter.
Sorry, your password does NOT meet requirements.

Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity4
This is for testing password validity.
Please enter a password (sorry, can't hide your password).
[input:] blaBla123
Yup, your password is at least 8 characters.
Yup, your password contains number.
Yup, your password contains letter.
Yup, your password contains uppercase letter.
Yup, your password contains lowercase letter.
Your password meets requirements.
______________________


// Activity 5:
Write a script that takes a number as an input and reverses it out to the user.
For example, if the original number is 74985, the output should be 58947.

Script CarlTangYongHan-scripting-activity5.txt
_________________________________
#!/bin/bash

echo Please input your number.
read input

# For calculation:
number=$input

# For concatenating string:
numString=""

# Remainder (dynamic):
R=0

while [ $number != 0 ]
do
	R=$((number%10))
	number=$(((number-R)/10))
	numString+="$R"
done

echo Reverted number is: $numString
__________________________________

Example running of script:
ubuntu@ip-172-31-17-240:~$ ./CarlTangYongHan-scripting-activity5.txt
Please input your number.
1234
Reverted number is: 4321
ubuntu@ip-172-31-17-240:~$ ./CarlTangYongHan-scripting-activity5.txt
Please input your number.
234500
Reverted number is: 005432
__________________________________


// Activity 6:
Create a script that takes two number parameters a and b and then shows True if a is larger than b or False otherwise.
Create a second version of the script that then tells the user the difference between the two numbers.
Remember to code defensively – ensure that your script handles things appropriately if someone enters things incorrectly!

Script CarlTangYongHan-scripting-activity6.txt
___________________________________
#!/bin/bash

echo Please give two parameters a and b
echo Parameter a:
read a
echo Parameter b:
read b

if [ -z "$a" ] || [ -a "$b" ]
then
        echo Inputs contain null value.
        exit 1
fi

regex='^[+-]?[0-9]+([.][0-9]+)?$'

if ! [[ $a =~ $regex ]] || ! [[ $b =~ $regex ]]
then
        echo Inputs contain non-number.
        exit 1
fi

if (( a > b ))
then
        echo True, a is larger than b.
else
        echo False, a is not larger than b.
fi
_________________________________

Script Activity6B:
_________________________________
$ cat Activity6B
#!/bin/bash

echo Please give two parameters a and b
echo Parameter a:
read a
echo Parameter b:
read b

if [ -z "$a" ] || [ -z "$b" ]
then
        echo Inputs contain null value.
        exit 1
fi

regex='^[+-]?[0-9]+([.][0-9]+)?$'

if ! [[ $a =~ $regex ]] || ! [[ $b =~ $regex ]]
then
        echo Inputs contain non-number.
        exit 1
fi

if (( a > b ))
then
        echo True, a is larger than b.
        echo Difference between two numbers is $(( $a - $b)).
else
        echo False, a is not larger than b.
        echo Difference between two numbers is $(( $b - $a)).
fi
____________________________________


// Activity 7:
Create a 10-question true or false quiz game in your script. Choose a topic of your liking for the questions!

Script Activity7:
____________________________________
#!/bin/bash

echo This is a True or False quiz game.
echo "Enter only 't' or 'f' for true or false."

# A separate text file is avoided for easier file management.

# Initiate arrays and block out the [0] location
Questions=("Start here:")
Answers=("Start here:")

# Record user's answers and right or wrong
InputAns=("User answers:")
InputWR=("Right or wrong:")
Score=0

# Populating questions array and answers array:

Questions+=("1. Linux was created by Linus Pauling.")
Answers+=("f")

Questions+=("2. Python was created by Linus Torvalds.")
Answers+=("f")

Questions+=("3. C comes before C++.")
Answers+=("t")

Questions+=("4. Python supports object-oriented programming.")
Answers+=("t")

Questions+=("5. Bash means 'Born as Shell'.")
Answers+=("f")

Questions+=("6. JavaScript evolved from Java.")
Answers+=("f")

Questions+=("7. AWS is a cloud service from Amazon.")
Answers+=("t")

Questions+=("8. Bash does not support for loops.")
Answers+=("f")

Questions+=("9. Linux Bash shares the same commands as DOS.")
Answers+=("f")

Questions+=("10. A Bash script starts with a shebang.")
Answers+=("t")

for i in {1..10}
do
        echo ${Questions[$i]}
        read input
        if [ $input != "t" ] && [ $input != "f" ]
        then
                echo Sorry, wrong input syntax, taken as error.
                InputAns[$i]="Error"
        else
                InputAns[$i]=$input
                if [ $input == ${Answers[$i]} ]
                then
                        Score=$((Score + 1))
                        InputWR[$i]="Right"
                        echo You are right!
                else
                        InputWR[$i]="Wrong"
                        echo Sorry, wrong answer.
                fi
        fi
done

echo You have scored: $Score out of 10.
echo Your answers are:
echo ${InputAns[@]}
echo ${InputWR[@]}
______________________________________________


// Activity 8:
Create a script that completes the following tasks:
1. It prompts the user for a series of 5-10 integers.
   - The user must be prompted for a minimum of 5 numbers.
   - After the user has entered 5 numbers, the program should allow the user to stop entry or enter another number.
2. When the user chooses to stop or after 10 numbers have been entered, the program stops prompting for values and performs the following calculations:
   - the product of the integers
   - the average of the integers
   - the sum of the integers
   - the min of the integers
   - the max of the integers
3. After performing the calculations, the program should display the following to the user:
   - the values the user entered
   - each of the calculations, using a phrase that identifies the value
   
Script Activity8:
_______________________________________________
#!/bin/bash


echo "Please enter 5-10 integers."

inputCount=0
userInputs=("User Inputs:")


# Target calculations to keep track
product=1
sum=0
min=""
max=""


# Checking input as numbers
regex='^[+-]?[0-9]+$'

while [ $inputCount -lt 10 ]
do
        read input

        # Give user choice to quit
        if [ $input == "n" ]
        then
                break
        else
                while ! [[ $input =~ $regex ]]
                do
                        echo Please enter a valid number
                        read input
                done
        fi
        userInputs+=($input)
        inputCount=$((inputCount + 1))
        echo inputCount is $inputCount


        # Give user choice to quit
        if [ $input == "n" ]
        then
                break
        fi

        # initiate min and max if necessary:
        if [ -z "$min" ]
        then
                min=$input
        fi

        if [ -z "$max" ]
        then
                max=$input
        fi


        # Update the latest min and max:

        if [ ${#userInputs[@]} > 1 ]
        then
                if [ $input -lt $min ]
                then
                        min=$input
                fi
        fi

        if [ ${#userInputs[@]} > 1 ]
        then
                if [ $input -gt $max ]
                then
                        max=$input
                fi
        fi


        # Update the latest product and sum:
        product=$((product * input))
        sum=$((sum + input))

        # Check for input requirements
        if [ $inputCount -lt 5 ]
        then
                echo Please make at least 5 inputs.
        elif [ $inputCount == 10 ]
        then
                echo You have input 10 integers, that is all.
        else
                echo You have input at least 5 integers,
                echo please feel free to input up to 10 integers.
                echo "Enter 'n' if you don't want to continue input."
        fi

done


# Part 2 & 3:

if [ $inputCount != 0 ]
then
        # Bash cannot do floating point division,
        # need alternative ways to divide
        largeQuotion=$((sum * 1000 / inputCount))
        remainder=$((largeQuotion%1000))
        average="$((sum / inputCount)).$remainder"
fi

if [ $inputCount -lt 5 ]
then
        echo "Sorry, you don't have at least 5 integers input."
else

        echo Your inputs are:
        echo ${userInputs[@]}

        if [ $inputCount != 0 ]
        then
                echo The product of the integers is $product
        fi

        if [ $inputCount != 0 ]
        then
                echo The average of the integers is $average
        fi

        echo The sum of the integers is $sum

        if [ $inputCount != 0 ]
        then
                echo The min of the integers is $min
        fi

        if [ $inputCount != 0 ]
        then
                echo The max of the integers is $max
        fi

fi
________________________________________________
Example of running the script:
______________________________________
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity8
Please enter 5-10 integers.
2
inputCount is 1
Please make at least 5 inputs.
3
inputCount is 2
Please make at least 5 inputs.
4
inputCount is 3
Please make at least 5 inputs.
5
inputCount is 4
Please make at least 5 inputs.
6
inputCount is 5
You have input at least 5 integers,
please feel free to input up to 10 integers.
Enter 'n' if you don't want to continue input.
7
inputCount is 6
You have input at least 5 integers,
please feel free to input up to 10 integers.
Enter 'n' if you don't want to continue input.
n
Your inputs are:
User Inputs: 2 3 4 5 6 7
The product of the integers is 5040
The average of the integers is 4.500
The sum of the integers is 27
The min of the integers is 2
The max of the integers is 7
________________________________________


// Activity 9:
Write a script that takes a file name as a parameter.
- If the file exists, print an error and return a code.
- If the file does not exist, create the file.

Script Activity9:
________________________
#!/bin/bash

echo Please provide file name to check.
read fileName

loc="./*"

for file in $loc
do
        echo Old file is $file
        echo new file is $fileName

        if [ "$fileName" == "$file" ]
        then
                echo Error: File already exist.
                exit 1
        else
                touch $fileName
                exit 0
        fi
done
_________________________________
### NOTE: Unknown bug occured, unable to debug on Git Bash.
### AWS vi is totally unusable at this point. Need to use Git Bash on local machine.


// Activity 10:
Write a script that writes random numbers to a file (one number per line).
- The first parameter should be the file name.
- The second parameter is the number of lines to write.
- If the specified file already exists, display a relevant message and return a code.

Script Activity10:
____________________________________
#!/bin/bash

echo Please provide file name and number of lines.

echo File name:
read fileName

echo Number of Lines:
read numLine

if [[ -f "$fileName" ]]
then
        echo Error: file name already exists.
        exit 1
else
        for i in `seq $numLine`
        do
                echo $RANDOM >> $fileName
        done
fi

echo Here is your file content:
cat $fileName
___________________________________
Example of running script:
________________________
Carl@DESKTOP-T2NNS4H MINGW64 ~
$ ./Activity10
Please provide file name and number of lines.
File name:
randomTry1
Number of Lines:
7
Here is your file content:
17885
24646
6437
32402
25250
29019
18215

Carl@DESKTOP-T2NNS4H MINGW64 ~
$ ./Activity10
Please provide file name and number of lines.
File name:
randomTry1
Number of Lines:
4
Error: file name already exists.
________________________


// Activity 11:
Create a file that includes the following numbers.
5 6 3 7 4 4 9 6 7 9 8 2 3 6 4 5 1 1 3 10 12
Write a script that uses this file to perform the following tasks:
- Read in the file
- Sort the numbers into reverse order and output them to the screen
- Each number should output exactly once. Duplicate numbers should not appear in the output.

A file of numbers is first created by pasting in the numbers above:
Carl@DESKTOP-T2NNS4H MINGW64 ~$ vi FileToSort

Script Activity11:
_____________________________________
#!/bin/bash

source="FileToSort"

echo Read and display source file:

read -a OriginalSeries < $source

echo ${OriginalSeries[@]}

# Initiate sorted array

# Replicate the OriginalSeries as sandBox


sandBox=(${OriginalSeries[@]})

length=${#OriginalSeries[@]}

max=${sandBox[0]}

for i in `seq 1 $((length-1))`
do
        iLoc=$((i-1))
        for j in `seq $((i + 1)) $length`
        do
                max=${sandBox[$iLoc]}

                jLoc=$((j-1))
                test=${sandBox[$jLoc]}

                if (( $max < $test ))
                then
                        sandBox[$iLoc]=$test
                        sandBox[$jLoc]=$max
                        max=sandBox[$iLoc]
                fi
        done
done

echo This is sorted list with duplicates:
echo ${sandBox[@]}


# For list without replication, replicate sandBox as smallBox

smallBox=(${sandBox[@]})


for i in `seq 1 $((length-1))`
do
        iLoc=$((i-1))
        for j in `seq $((i + 1)) $length`
        do
                stay=${smallBox[$iLoc]}

                jLoc=$((j-1))
                test=${smallBox[$jLoc]}

                if [ "$stay" == "$test" ]
                then
                        unset smallBox[$jLoc]
                else
                        continue
                fi
        done
done

echo This is sorted list with NO duplicates:
echo ${smallBox[@]}

_____________________________________

Outcomes of Running Script:
_______________________________
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity11
Read and display source file:
5 6 3 7 4 4 9 6 7 9 8 2 3 6 4 5 1 1 3 10 12
This is sorted list with duplicates:
12 10 9 9 8 7 7 6 6 6 5 5 4 4 4 3 3 3 2 1 1
This is sorted list with NO duplicates:
12 10 9 8 7 6 5 4 3 2 1
_______________________________


// Activity 12:
Write a script that checks if two files have at least one common element or not.
Display an appropriate message for both scenarios. The file names should be specified as parameters.
You will need to create the files to test this.

Sample files creation (3 files to compare for positive and negative results):

Carl@DESKTOP-T2NNS4H MINGW64 ~$ echo The quick brown fox jumps over the lazy dog > compareFile1

Carl@DESKTOP-T2NNS4H MINGW64 ~$ echo Dog does not sleep like the cat > compareFile2

Carl@DESKTOP-T2NNS4H MINGW64 ~$ echo Spider-man is not a normal spider nor a normal man > compareFile3

Script Activity12:
_______________________________________
#!/bin/bash

echo Please provide two files for comparison.

echo File 1:
read file1

echo File 2:
read file2

# Read actual files to create arrays of words
read -a wordSet1 < $file1
read -a wordSet2 < $file2

# Initialize flag
gotCommon=0

length1=${#wordSet1[@]}
length2=${#wordSet2[@]}

for i in `seq 1 $length1`
do
        iLoc=$((i-1))
        wordHere=${wordSet1[$iLoc]}

        for j in `seq 1 $length2`
        do
                jLoc=$((j-1))
                wordThere=${wordSet2[$jLoc]}

                if [ "$wordHere" == "$wordThere" ]
                then
                        gotCommon=$((gotCommon + 1))
                        echo Common element found: $wordHere
                        exit 0
                fi
        done
done


# In case there is no common element:
if (( gotCommon < 1 ))
then
        echo There is no common element between the files.
fi
_______________________________________

Testing the script with two pairs of files:
_________________________________
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity12
Please provide two files for comparison.
File 1:
compareFile1
File 2:
compareFile2
Common element found: the

Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity12
Please provide two files for comparison.
File 1:
compareFile1
File 2:
compareFile3
There is no common element between the files.
_______________________________



// Activity 13:
Write a script that takes two files of unique numbers and displays the difference between the two lists (without using grep).
#### Stretch: Create a new script that does the same thing using grep. Which script runs faster?

Script Activity13:
____________________________________
#!/bin/bash

echo Please provide two files.

echo File 1:
read file1

echo File 2:
read file2

# Pulling data from actual files to create arrays.
while read -r line; do list1+=("$line"); done < $file1
while read -r line; do list2+=("$line"); done < $file2

# Initialize unique lists
uniqueList1=("${list1[@]}")
uniqueList2=("${list2[@]}")

length1=${#list1[@]}
length2=${#list2[@]}

# Tract movement of checking base list
checkLoc=0
target=$length1

iLoc=0
jLoc=0

while ((iLoc < length1))
do
        base=${uniqueList1[$iLoc]}

        jLoc=0

        while ((jLoc < length2))
        do
                there=${uniqueList2[$jLoc]}

                if (( base == there ))
                then
                        unset uniqueList1[$iLoc]
                        uniqueList1=(`echo ${uniqueList1[@]}`)
                        unset uniqueList2[$jLoc]
                        uniqueList2=(`echo ${uniqueList2[@]}`)

                        length1=${#uniqueList1[@]}
                        length2=${#uniqueList2[@]}

                        iLoc=$((iLoc - 1))
                        break
                fi

                jLoc=$((jLoc + 1))
        done

        iLoc=$((iLoc + 1))
done

if [ ${#uniqueList1[@]} == 0 ]
then
        echo File 1 does not have elements not found in File 2.
else
        echo Only in File 1:
        echo ${uniqueList1[@]}
fi


if [ ${#uniqueList2[@]} == 0 ]
then
        echo File 2 does not have elements not found in File 1.
else
        echo Only in File 2:
        echo ${uniqueList2[@]}
fi
____________________________________

Sample test files:
Carl@DESKTOP-T2NNS4H MINGW64 ~$ vi compareAct13-1

Carl@DESKTOP-T2NNS4H MINGW64 ~$ vi compareAct13-2

Carl@DESKTOP-T2NNS4H MINGW64 ~$ cat compareAct13-1
1
2
13
4
6
25
79
64

Carl@DESKTOP-T2NNS4H MINGW64 ~$ cat compareAct13-2
1
64
2
89
6
13
7

Outcomes of running script:
_______________________________
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity13
Please provide two files.
File 1:
compareAct13-1
File 2:
compareAct13-2
Only in File 1:
4 25 79
Only in File 2:
89 7
_______________________________



// Activity 14:
In the materials folder on the server you will find a file called books. Copy this file to your home directory.
Write a script that will parse the file, producing an output csv file that will list the word and each time it appears in the file.
Make sure the list is sorted in the file such that the most common word is listed at the top and then descending.
For example, a couple of lines in the output file should look like this:
   And,200
   Is,195
   
### NOTE: as I am not aware of any materials folder on a common server that students can access,
I am using the data of the Top 500 Novels from: https://www.oclc.org/en/worldcat/library100/top500.html

The raw data is kept in a file called "books".

The data looks like this:
___________________________________
1       Don Quixote
2       Alice's Adventures in Wonderland
3       The Adventures of Huckleberry Finn
4       The Adventures of Tom Sawyer
7       Wuthering Heights
10      The Scarlet Letter
13      A Christmas Carol
15      A Tale of Two Cities
16      Little Women
17      Great Expectations
18      The Hobbit, or, There and Back Again
19      Frankenstein, or, the Modern Prometheus
20      Oliver Twist
... (followed by the next 480 novels)
____________________________________

Script Activity14:
_______________________________________
#!/bin/bash

# This Activity uses a self-created book list of 500 top novels,
# derived from https://www.oclc.org/en/worldcat/library100/top500.html


sourceFile="books"

# Clean up punctuations and numbers, including numbers found in book names.
# All replaced by a space, to be further cleaned up later on. After that,
# convert all words to the same form of capitalization of first character.

sed -e 's/[[:punct:]]/ /g' $sourceFile | sed -e 's/[0-9]/ /g' | \
        sed -e 's/[A-Z]/\L&/g' | sed -e 's/\<./\U&/g' > sourceFile2

# Clean up all sorts of spaces, leaving only words separated by new lines,

cat sourceFile2 | tr -s [:space:] '\n' > sourceFile3
rm sourceFile2

# Sort the words in file,
# deduplicate the words while printing out number of occurrences.
# sort by numbers in reverse order

cat sourceFile3 | sort | uniq -c | sort -n -r > cleanBooks
rm sourceFile3

# Format the outcome into desired csv file.
# As awk would add extra spaces, we need to remove space again.
awk '{print $2, ",", $1}' cleanBooks | sed 's/ //g' > books.csv
rm cleanBooks
_______________________________________
Output of running the script, which is "books.csv":
___________________________________
Carl@DESKTOP-T2NNS4H MINGW64 ~
$ cat books.csv | less
The,307
Of,108
And,38
A,37
S,28
In,26
To,11
On,11
House,9
For,9
King,8
Time,7
Potter,7
Little,7
Harry,7
Girl,6
With,5
Tale,5
Red,5
Man,5
Life,5
Last,5
Adventures,5
... (the list goes on)
____________________________________



// Activity 15:
Imagine that you support the fix Generator script. Write a wrapper script to set up your environment properly.
You can also edit the fixGenerator script if you need to.
Your fixGenerator script should be in a folder called FixGen in your home directory. The script needs to do the following:
 - Check for a folder called FixGen/logs and if not present create it
 - Compress all log files that are not the latest 3 logs files generated.
 - Run the FixGenerator script with the log file being generated into the FixGen/logs directory.
Once complete, add a cron job that will run Monday through Friday 6 a.m. to establish your environment.
Remember to code defensively and ensure that you use exit codes so we know the job has successfully run.
Your script should also output its own log file where we can see the status each step of the way of each part of the script.

## The command "exit 0" was added to fixGenerator, and the file is now called "fixGenerator2.sh".

Script Activity15:
__________________________________
#!/bin/bash

# Activity 15:


# Create a log file for this wrapper script running itself:
wrapperLog="wrapperLog"`date "+%Y%m%d%H%M%S"`".log"
if [ ! -d /wrapperLogDir-Activity15 ]
then
        mkdir -p "wrapperLogDir-Activity15"
fi

# Make convenient location for logging later
wrapLoc="./wrapperLogDir-Activity15/$wrapperLog"
wrapLocFromHome="/c/Users/Carl/wrapperLogDir-Activity15/$wrapperLog"
## Note: the path refers to my Windows system which runs Git Bash for this Activity.
## No /home/ available.

touch $wrapLoc
echo "The wrapper log $wrapperLog was initiated at `date`." >> $wrapLoc

# The fix generator script:
fixGenerator=fixGenerator2.sh

# Check for a folder "FixGen/logs",
# Assuming wrapper script is always in Home directory.

# Compose multiple levels of directory:
dirLevel1="FixGen"
dirLevel2="logs"
wantedDir="$dirLevel1/$dirLevel2"


# Run the fixGenerator script in the wanted directory as cron asks the wrapper script to.
# Capture exit code, with the fixGenerator already amended to offer exit code.
echo "The fixGenerator script was activated at `date`." >> $wrapLoc
FGExit=`./$wantedDir/$fixGenerator | echo $?`

if [ $FGExit == 0 ]
then
        echo "The fixGenerator runs successfully, completed `date`." >> $wrapLoc
else
        echo "The fixGenerator failed, wrapper script exited `date`." >> $wrapLoc
        exit 1
fi


# Start checking the directory

if [ ! -d "/$dirLevel1" ]
then
        mkdir -p $dirLevel1
        mkdir -p $wantedDir
        echo The previously non-existent /$dirLevel1 is created, >> $wrapLoc
        echo ... followed by /$wantedDir. >> $wrapLoc
else
        cd $dirLevel1/.
        if ! [ -d "/$dirLevel2" ]
        then
                # Create Level 2 directory if not already there
                mkdir -p $dirLevel2
                echo The directory /$dirLevel1 exists but ./$dirLevel2 did not, >> $wrapLoc
                echo ... hence /$wantedDir was created. >> $wrapLoc
        else
                cd $dirLevel2/.
                # if folder already exist, append "fixlog0"
                # as prefix to any file, to make them old
                # and ready to archive.
                for fileName in *
                do
                        ### Due to the danger of the following command,
                        ### I have commented it out. When I know better,
                        ### I might implement this feature again.
                        ### for now it's lucky that the directory is empty.

                        ## mv $fileName "fixlog0$fileName"
                        :
                done
                cd ..
        fi
        cd ~
fi

# In case some of the log files are scattered in home directory,
# move them into the wanted directory above.

outsideLog=(`ls fixlog*`)
outsideLogCount=${#outsideLog[@]}

if [ $outsideLogCount -gt 0 ]
then
        mv fixlog* $wantedDir/.
        echo "Found $outsideLogCount log file(s) in home directory." >> $wrapLoc
        echo "Moved $outsideLogCount log file(s) to ~/$wantedDir/." >> $wrapLoc
fi


# In case fixGenerator script is still in home directory,
# move it into the wanted directory above.

if [ -f "$fixGenerator" ]
then
        mv $fixGenerator $wantedDir/.
        echo "Moved $fixGenerator from home directory to ~/$wantedDir/." >> $wrapLoc
fi


# Compress all log files that are not the latest 3 log files generated:
cd $wantedDir/.

# Count how many log files are found lying around
# Make an array of log file names for later use

logArray=(`ls fixlog* | sort`)
numLogs=${#logArray[@]}

# if there are only 3 log files, do nothing,
# but with more log files, check if an archive file already exists.
if [ $numLogs -le 3 ]
then
        :
else
        # Here we have at least 4 log files,
        # hence create archive file or add extra files to existing archive
        if ! [ -f logArchive.tar ]
        then
                # If archive file does not exist,
                # Use the oldest log file to start one.
                tar -cvf logArchive.tar ${logArray[0]}
                echo Oldest log file ${logArray[0]} used to start archive tar file. >> $wrapLocFromHome
                # Remove the archived log file from array
                unset logArray[0]
                logArray=(`echo ${logArray[@]}`)
                numLogs=${#logArray[@]}
        fi

        # Now start to add log files to existing archive
        # In order to keep the latest 3, figure out the
        # array location of last archivable log file:
        lastLoc=$((numLogs - 4))

        for i in `seq 0 $lastLoc`
        do
                # Append each older log file to archive
                tar -rvf logArchive.tar ${logArray[$i]}
                echo The file ${logArray[$i]} was archived. >> $wrapLocFromHome
                # Remove archived file from directory
                rm ${logArray[$i]}
        done
fi

cd ~

exit 0
__________________________________

Test running script:
_____________________________
## Show the file structure already created with running the script once,
## along with the log files generated and moved into this folder so far:
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ls FixGen/logs
fixGenerator2.sh*         fixlog20220731162751.log  fixlog20220731175109.log
fixlog20220731161058.log  fixlog20220731163344.log  fixlog20220731181003.log
fixlog20220731162524.log  fixlog20220731164141.log  fixlog20220731183547.log

## Test running the script without generating new log file and without cron scheduling:
## (to test compression of old log files)
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ls FixGen/logs
fixGenerator2.sh*         fixlog20220731181003.log  logArchive.tar
fixlog20220731175109.log  fixlog20220731183547.log

## Look inside archive file:
Carl@DESKTOP-T2NNS4H MINGW64 ~/FixGen/logs$ tar -tvf logArchive.tar
-rw-r--r-- Carl/197121   51509 2022-07-31 16:14 fixlog20220731161058.log
-rw-r--r-- Carl/197121   11517 2022-07-31 16:27 fixlog20220731162524.log
-rw-r--r-- Carl/197121   52439 2022-07-31 16:31 fixlog20220731162751.log
-rw-r--r-- Carl/197121   49297 2022-07-31 16:37 fixlog20220731163344.log
-rw-r--r-- Carl/197121   52098 2022-07-31 16:45 fixlog20220731164141.log

## The above shows that 5 out of 8 log files are archived, leaving the latest 3 log files.
## The following shows that at later tests, more log files are archived, leaving the latest three.
Carl@DESKTOP-T2NNS4H MINGW64 ~
$ ls FixGen/logs
fixGenerator2.sh*         fixlog20220801003408.log  logArchive.tar
fixlog20220801003339.log  fixlog20220801003502.log

Carl@DESKTOP-T2NNS4H MINGW64 ~$ tar -tvf FixGen/logs/logArchive.tar
-rw-r--r-- Carl/197121   51509 2022-07-31 16:14 fixlog20220731161058.log
-rw-r--r-- Carl/197121   11517 2022-07-31 16:27 fixlog20220731162524.log
-rw-r--r-- Carl/197121   52439 2022-07-31 16:31 fixlog20220731162751.log
-rw-r--r-- Carl/197121   49297 2022-07-31 16:37 fixlog20220731163344.log
-rw-r--r-- Carl/197121   52098 2022-07-31 16:45 fixlog20220731164141.log
-rw-r--r-- Carl/197121   55963 2022-07-31 17:55 fixlog20220731175109.log
-rw-r--r-- Carl/197121   50182 2022-07-31 18:13 fixlog20220731181003.log
-rw-r--r-- Carl/197121   50602 2022-07-31 18:39 fixlog20220731183547.log
-rw-r--r-- Carl/197121    1950 2022-07-31 20:39 fixlog20220731203917.log
-rw-r--r-- Carl/197121   50725 2022-07-31 21:04 fixlog20220731210023.log
-rw-r--r-- Carl/197121     972 2022-07-31 23:26 fixlog20220731232614.log
-rw-r--r-- Carl/197121     162 2022-07-31 23:27 fixlog20220731232735.log
-rw-r--r-- Carl/197121    1296 2022-07-31 23:44 fixlog20220731234419.log
-rw-r--r-- Carl/197121   49492 2022-07-31 23:54 fixlog20220731235029.log
-rw-r--r-- Carl/197121   50163 2022-07-31 23:58 fixlog20220731235415.log
-rw-r--r-- Carl/197121    1296 2022-08-01 00:31 fixlog20220801003127.log

## Example of a wrapper log file (one is created every time the wrapper script is run):
# Script successfully run, some fixlog files were affected, i.e. moved and/or archived.
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity15
fixlog20220801012550.log
fixlog20220801014303.log
fixlog20220801015835.log
fixlog20220801021159.log

# Prove that the wrapper script ran well:
Carl@DESKTOP-T2NNS4H MINGW64 ~$ echo $?
0

# Look up the directory keeping the wrapper script's log files:
Carl@DESKTOP-T2NNS4H MINGW64 ~$ cd wrapperLogDir-Activity15/; ls
wrapperLog20220801003501.log  wrapperLog20220801015835.log
wrapperLog20220801014303.log  wrapperLog20220801023133.log

# Checking the contents of the latest wrapper log file:
Carl@DESKTOP-T2NNS4H MINGW64 ~/wrapperLogDir-Activity15$ cat wrapperLog20220801023133.log
The wrapper log wrapperLog20220801023133.log was initiated at Mon Aug  1 02:31:33 MPST 2022.
The fixGenerator script was activated at Mon Aug  1 02:31:33 MPST 2022.
The fixGenerator runs successfully, completed Mon Aug  1 02:35:44 MPST 2022.
The previously non-existent /FixGen is created,    ### Mysteriously echoed although the logic says otherwise.
... followed by /FixGen/logs.                      ### Mysteriously echoed although the logic says otherwise.
Found 2 log file(s) in home directory.
Moved 2 log file(s) to ~/FixGen/logs/.
The file fixlog20220801012550.log was archived.
The file fixlog20220801014303.log was archived.
The file fixlog20220801015835.log was archived.
The file fixlog20220801021159.log was archived.

__________________________________

## As I am using Git Bash on Windows, I am unable to install packages,
## and cron does not come preinstalled.
## This is my equivalent of /home/
Carl@DESKTOP-T2NNS4H MINGW64 ~$ pwd
/c/Users/Carl

# Suppose I could use the path /home/, and could crontab -e to edit cron jobs,
# I would have written this:

0 6 * * 1-5 /home/Activity14   (I didn't use .sh for my file name)



// Activity 16:
Write a script that will output a csv that could be loaded into ITRS Geneos for monitoring on your fixGen script.
 - It needs to parse the log file and produce a count of each message type that has been received or sent.
 - Ensure you distinguish in the csv file if the message was sent or received.
 - Also ensure you display the message type in English so it is easy to understand in monitoring.
   An example might look like:
             Number of Partial fills,12

## All messages have a send party and receive party. I am assuming the position of the broker,
## to determine if I am sending to client or receiving from client.

Script Activity16:
____________________________________
#!/bin/bash


# Location of log file:
fileDir="./FixGen/logs/"

# Ask for file name:
echo Please provide file name:
read fileName

# Actual log file:
logFile="$fileDir$fileName"

# Extract Date and Time:
# dateTime=$(echo $fileName | sed 's/fixlog//g')




### Codes Definition

# Parties
client="MTHREE"
broker="MS"

# Send or receive codes
sendCode="49=$broker"
receiveCode="56=$broker"



# Message Type <35>

Message35Items=("Logon Type" "News Type" "Email Type" "New Order Single Type" "New Order List Type" "Order Cancel Request Type" "Order Cancel/Replace Request Type" "Order Status Request Type" "Allocation Type" "List Cancel Request Type" "List Execute Type" "List Status Request Type" "Heartbeat Type" "Test Request Type" "Resend Request Type" "Reject Type" "Sequence Reset Type" "Logout Type" "Indication of Interest Type" "Advertisement Type" "Execution Report Type" "Order Cancel Reject Type")

Message35Codes=("35=A" "35=B" "35=C" "35=D" "35=E" "35=F" "35=G" "35=H" "35=J" "35=K" "35=L" "35=M" "35=0" "35=1" "35=2" "35=3" "35=4" "35=5" "35=6" "35=7" "35=8" "35=9")



# Order Status Message Types <39>

Message39Items=("New Order" "Partial Fill Order" "Fill Order" "Done for the Day Order" "Cancelled Order" "Replace Order" "Pending Cancel Order" "Stopped Set Order" "Rejected Order" "Suspended Order")

Message39Codes=("39=0" "39=1" "39=2" "39=3" "39=4" "39=5" "39=6" "39=7" "39=8" "39=9")



# Execution Report Message Types (150)

Message150Items=("New Exec" "Partial Fill Exec" "Fill Exec" "Done for the Day Exec" "Cancelled Order Exec" "Replace Exec" "Pending Cancel Exec" "Stopped Set Exec" "Rejected Exec" "Suspended Order")

Message150Codes=("150=0" "150=1" "150=2" "150=3" "150=4" "150=5" "150=6" "150=7" "150=8" "150=9")



# Execution Transaction Type <20>

Message20Items=("New Order Ack Transact Type" "Cancel Prev Reported Exec Tr" "Correction to Prev Reported Exec Tr" "Report Status of Orders Exec Tr")

Message20Codes=("20=0" "20=1" "20=2" "20=3")




### Start Processing and Outputing

# Start reading data
dateTime=$(echo $fileName | sed 's/fixlog//g' | sed 's/.log//g')


# Output file for ITRS:
outputFile="ITRS$dateTime.csv"
touch $outputFile

# Make headers:
echo SEND-RECv,ITEM,DATA >> $outputFile

# Date
echo "N/A,Date and Time,$dateTime" >> $outputFile



# Loop to List out Messages of Tag <35>
count35=${#Message35Items[@]}
endLoc35=$((count35 - 1))
echo "N/A,Message Type <35>,N/A" >> $outputFile
for i in `seq 0 $endLoc35`
do
        item=${Message35Items[$i]}
        sendCount=$(cat $logFile | grep "${Message35Codes[$i]}" | grep -c "$sendCode" )
        receiveCount=$(cat $logFile | grep "${Message35Codes[$i]}" | grep -c "$receiveCode" )

        # Minimize print-out by giving out only the non-zero send or receive side,
        # if the counter-side is zero. If both sides are zero, print both as zero
        # because it's ambiguous which side is the position supposedly taken.
        # Will display N/A if both send and receive are zeros.

        if [ $receiveCount -eq 0 ] && [ $sendCount -eq 0 ]
        then
                echo "N/A,$item,0" >> $outputFile
        elif [ $sendCount -ne 0 ]
        then
                echo "Send,$item,$sendCount" >> $outputFile
        elif [ $receiveCount -ne 0 ]
        then
                echo "Receive,$item,$receiveCount" >> $outputFile
        fi
done



# Loop to List out Messages of Tag <39>
count39=${#Message39Items[@]}
endLoc39=$((count39 - 1))
echo "N/A,Order Status Message Type <39>,N/A" >> $outputFile
for i in `seq 0 $endLoc39`
do
        item=${Message39Items[$i]}
        sendCount=$(cat $logFile | grep "${Message39Codes[$i]}" | grep -c "$sendCode" )
        receiveCount=$(cat $logFile | grep "${Message39Codes[$i]}" | grep -c "$receiveCode" )

        # Minimize print-out by giving out only the non-zero send or receive side,
        # if the counter-side is zero. If both sides are zero, print both as zero
        # because it's ambiguous which side is the position supposedly taken.
        # Will display N/A if both send and receive are zeros.

        if [ $receiveCount -eq 0 ] && [ $sendCount -eq 0 ]
        then
                echo "N/A,$item,0" >> $outputFile
        elif [ $sendCount -ne 0 ]
        then
                echo "Send,$item,$sendCount" >> $outputFile
        elif [ $receiveCount -ne 0 ]
        then
                echo "Receive,$item,$receiveCount" >> $outputFile
        fi
done



# Loop to List out Messages of Tag <150>
count150=${#Message150Items[@]}
endLoc150=$((count150 - 1))
echo "N/A,Execution Report Message Type <150>,N/A" >> $outputFile
for i in `seq 0 $endLoc150`
do

        item=${Message150Items[$i]}
        sendCount=$(cat $logFile | grep "${Message150Codes[$i]}" | grep -c "$sendCode" )
        receiveCount=$(cat $logFile | grep "${Message150Codes[$i]}" | grep -c "$receiveCode" )

        # Minimize print-out by giving out only the non-zero send or receive side,
        # if the counter-side is zero. If both sides are zero, print both as zero
        # because it's ambiguous which side is the position supposedly taken.
        # Will display N/A if both send and receive are zeros.

        if [ $receiveCount -eq 0 ] && [ $sendCount -eq 0 ]
        then
                echo "N/A,$item,0" >> $outputFile
        elif [ $sendCount -ne 0 ]
        then
                echo "Send,$item,$sendCount" >> $outputFile
        elif [ $receiveCount -ne 0 ]
        then
                echo "Receive,$item,$receiveCount" >> $outputFile
        fi
done



# Loop to List out Messages of Tag <20>
count20=${#Message20Items[@]}
endLoc20=$((count20 - 1))
echo "N/A,Execution Transaction Type <20>,N/A" >> $outputFile
for i in `seq 0 $endLoc20`
do

        item=${Message20Items[$i]}
        sendCount=$(cat $logFile | grep "${Message20Codes[$i]}" | grep -c "$sendCode" )
        receiveCount=$(cat $logFile | grep "${Message20Codes[$i]}" | grep -c "$receiveCode" )

        # Minimize print-out by giving out only the non-zero send or receive side,
        # if the counter-side is zero. If both sides are zero, print both as zero
        # because it's ambiguous which side is the position supposedly taken.
        # Will display N/A if both send and receive are zeros.

        if [ $receiveCount -eq 0 ] && [ $sendCount -eq 0 ]
        then
                echo "N/A,$item,0" >> $outputFile
        elif [ $sendCount -ne 0 ]
        then
                echo "Send,$item,$sendCount" >> $outputFile
        elif [ $receiveCount -ne 0 ]
        then
                echo "Receive,$item,$receiveCount" >> $outputFile
        fi
done



mv "$outputFile" "$fileDir$outputFile"

exit 0
____________________________________
Output of test running the script:
______________________________
Carl@DESKTOP-T2NNS4H MINGW64 ~$ ./Activity16
Please provide file name:
fixlog20220801023133.log

Carl@DESKTOP-T2NNS4H MINGW64 ~$ echo $?
0

Carl@DESKTOP-T2NNS4H MINGW64 ~$ cat FixGen/logs/ITRS20220801023133.csv
SEND-RECv,ITEM,DATA
N/A,Date and Time,20220801023133
N/A,Message Type <35>,N/A
Send,Logon Type,1
N/A,News Type,0
N/A,Email Type,0
Receive,New Order Single Type,39
N/A,New Order List Type,0
Receive,Order Cancel Request Type,21
N/A,Order Cancel/Replace Request Type,0
N/A,Order Status Request Type,0
N/A,Allocation Type,0
N/A,List Cancel Request Type,0
N/A,List Execute Type,0
N/A,List Status Request Type,0
Send,Heartbeat Type,50
N/A,Test Request Type,0
N/A,Resend Request Type,0
N/A,Reject Type,0
N/A,Sequence Reset Type,0
N/A,Logout Type,0
N/A,Indication of Interest Type,0
N/A,Advertisement Type,0
Send,Execution Report Type,125
N/A,Order Cancel Reject Type,0
N/A,Order Status Message Type <39>,N/A
Send,New Order,39
Send,Partial Fill Order,26
Send,Fill Order,18
N/A,Done for the Day Order,0
Send,Cancelled Order,21
N/A,Replace Order,0
Send,Pending Cancel Order,21
N/A,Stopped Set Order,0
N/A,Rejected Order,0
N/A,Suspended Order,0
N/A,Execution Report Message Type <150>,N/A
Send,New Exec,39
Send,Partial Fill Exec,26
Send,Fill Exec,18
N/A,Done for the Day Exec,0
Send,Cancelled Order Exec,21
N/A,Replace Exec,0
Send,Pending Cancel Exec,21
N/A,Stopped Set Exec,0
N/A,Rejected Exec,0
N/A,Suspended Order,0
N/A,Execution Transaction Type <20>,N/A
N/A,New Order Ack Transact Type,0
N/A,Cancel Prev Reported Exec Tr,0
N/A,Correction to Prev Reported Exec Tr,0
N/A,Report Status of Orders Exec Tr,0

______________________________



// Activity 17: (Insufficient time to complete)
Create a script to convert your fix log file into a useful csv.
Pull out the following information for each message:
 - If the fix tag is in the message, leave a blank in the csv so that it will load appropriately in Excel.
 - Translate the message type value into meaningful words.
 - Ensure you have a header row in your csv file:
Client, Message type, stock, quantity, price, side, order id, last quantity, exec id, last price 




// Activity 18: (Insufficient time to complete)
Run the fixGenerator script to generate a fix log file.
 - Create a script to parse that log file and for each order create a text description of what happened with that order.
 - This should go into a log file with a paragraph for each order.
For example:

New buy order for apple with order id 12335, 100 shares at price 54.2 
Partial fill for apple with order id 12335, 20 shares at price 54.2
Cancel message for apple with order id 12335
Final state of order for apple with order id 12335: traded 40 shares at price 54.2. 

Remember that each time you run the fix generator script, it creates a new log file so this is a good way to test.


_______________________________




